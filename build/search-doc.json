{"searchDocs":[{"title":"BezierFactory","type":0,"sectionRef":"#","url":"/Mathf/api/BezierFactory","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"BezierFactory","url":"/Mathf/api/BezierFactory#functions","content":" ","version":null,"tagName":"h2"},{"title":"Create​","type":1,"pageTitle":"BezierFactory","url":"/Mathf/api/BezierFactory#Create","content":"&lt;/&gt; BezierFactory.Create( P1x: number,-- First control point X coordinate (typically 0-1) P1y: number,-- First control point Y coordinate (can be any value) P2x: number,-- Second control point X coordinate (typically 0-1) P2y: number-- Second control point Y coordinate (can be any value) ) → function-- Easing function that takes time [0-1] and returns interpolated value Creates a cubic Bezier easing function with custom control points. Control points define the shape of the interpolation curve. Usage Notes: Control points (P1x, P1y) and (P2x, P2y) define the curve shape X values should typically be in range [0, 1] for predictable results Y values can exceed [0, 1] for overshoot/undershoot effects Uses Newton-Raphson iteration for accurate time calculation Compatible with CSS cubic-bezier() format Common Presets: -- Ease-in-out (smooth start and end) local ease = BezierFactory.Create(0.42, 0, 0.58, 1) -- Ease-out (fast start, slow end) local easeOut = BezierFactory.Create(0, 0, 0.58, 1) -- Ease-in (slow start, fast end) local easeIn = BezierFactory.Create(0.42, 0, 1, 1) -- Bounce effect (overshoot) local bounce = BezierFactory.Create(0.68, -0.55, 0.265, 1.55) Example: local customEase = BezierFactory.Create(0.25, 0.1, 0.25, 1) -- Animate from 0 to 100 over time 0-1 for t = 0, 1, 0.1 do local value = customEase(t) * 100 print(string.format(&quot;Time: %.1f, Value: %.1f&quot;, t, value)) end   ","version":null,"tagName":"h3"},{"title":"Linear​","type":1,"pageTitle":"BezierFactory","url":"/Mathf/api/BezierFactory#Linear","content":"&lt;/&gt; BezierFactory.Linear() → function-- Linear easing function Creates a linear easing function (no acceleration/deceleration). Usage Notes: Equivalent to BezierFactory.Create(0, 0, 1, 1) Constant speed throughout animation Useful as baseline for comparing other easing functions Example: local linear = BezierFactory.Linear() print(linear(0.5)) -- 0.5 (exactly halfway)   ","version":null,"tagName":"h3"},{"title":"EaseInOut​","type":1,"pageTitle":"BezierFactory","url":"/Mathf/api/BezierFactory#EaseInOut","content":"&lt;/&gt; BezierFactory.EaseInOut() → function-- Ease-in-out easing function Creates an ease-in-out easing function (smooth acceleration and deceleration). Common default for smooth animations. Usage Notes: Equivalent to CSS ease-in-out and BezierFactory.Create(0.42, 0, 0.58, 1) Starts slow, speeds up in middle, slows down at end Most natural feeling for UI animations Example: local ease = BezierFactory.EaseInOut() -- Use for smooth button animations   ","version":null,"tagName":"h3"},{"title":"EaseOut​","type":1,"pageTitle":"BezierFactory","url":"/Mathf/api/BezierFactory#EaseOut","content":"&lt;/&gt; BezierFactory.EaseOut() → function-- Ease-out easing function Creates an ease-out easing function (fast start, slow end). Great for objects coming to rest naturally. Usage Notes: Equivalent to CSS ease-out and BezierFactory.Create(0, 0, 0.58, 1) Rapid initial movement that gradually slows Perfect for dropdown menus and sliding panels Example: local easeOut = BezierFactory.EaseOut() -- Use for menu slide-ins   ","version":null,"tagName":"h3"},{"title":"EaseIn​","type":1,"pageTitle":"BezierFactory","url":"/Mathf/api/BezierFactory#EaseIn","content":"&lt;/&gt; BezierFactory.EaseIn() → function-- Ease-in easing function Creates an ease-in easing function (slow start, fast end). Useful for objects accelerating away. Usage Notes: Equivalent to CSS ease-in and BezierFactory.Create(0.42, 0, 1, 1) Gradual start that rapidly accelerates Good for objects being launched or thrown Example: local easeIn = BezierFactory.EaseIn() -- Use for projectile launches   ","version":null,"tagName":"h3"},{"title":"ValidateControlPoints​","type":1,"pageTitle":"BezierFactory","url":"/Mathf/api/BezierFactory#ValidateControlPoints","content":"&lt;/&gt; BezierFactory.ValidateControlPoints( P1x: number,-- First control point X P1y: number,-- First control point Y P2x: number,-- Second control point X P2y: number-- Second control point Y ) → boolean-- True if control points will produce a valid curve Validates if control points will produce a valid monotonic curve. Monotonic curves don't reverse direction (always increasing or constant). Usage Notes: X coordinates should be in range [0, 1] for monotonic curves Non-monotonic curves can cause unexpected animation behavior This function helps catch problematic control point values Example: if BezierFactory.ValidateControlPoints(0.5, 0.5, 0.3, 0.8) then print(&quot;Valid control points&quot;) else warn(&quot;Control points may cause issues&quot;) end   ","version":null,"tagName":"h3"},{"title":"SampleCurve​","type":1,"pageTitle":"BezierFactory","url":"/Mathf/api/BezierFactory#SampleCurve","content":"&lt;/&gt; BezierFactory.SampleCurve( easingFunction: function,-- The easing function to sample sampleCount: number-- Number of samples to take (default: 10) ) → table-- Array of {time: number, value: number} tables Samples a Bezier curve at regular intervals for visualization or debugging. Usage Notes: Returns table of {time, value} pairs Useful for plotting curves or debugging easing functions Higher sample counts provide smoother visualization but more computation Example: local ease = BezierFactory.Create(0.25, 0.1, 0.25, 1) local samples = BezierFactory.SampleCurve(ease, 20) for _, point in ipairs(samples) do print(string.format(&quot;t: %.2f, v: %.2f&quot;, point.time, point.value)) end  ","version":null,"tagName":"h3"},{"title":"ExperienceCalculator","type":0,"sectionRef":"#","url":"/Mathf/api/ExperienceCalculator","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"ExperienceCalculator","url":"/Mathf/api/ExperienceCalculator#functions","content":" ","version":null,"tagName":"h2"},{"title":"SetExperienceFactor​","type":1,"pageTitle":"ExperienceCalculator","url":"/Mathf/api/ExperienceCalculator#SetExperienceFactor","content":"&lt;/&gt; ExperienceCalculator.SetExperienceFactor( factor: number-- The scaling factor for experience calculations ) → () Sets the experience scaling factor that affects level progression curve. Higher values make leveling slower, lower values make it faster. Usage Notes: Default factor is 200 Must be positive number Affects all level calculations globally Change this before performing any calculations for consistency Example: ExperienceCalculator.SetExperienceFactor(150) -- Faster progression ExperienceCalculator.SetExperienceFactor(300) -- Slower progression   ","version":null,"tagName":"h3"},{"title":"GetExperienceFactor​","type":1,"pageTitle":"ExperienceCalculator","url":"/Mathf/api/ExperienceCalculator#GetExperienceFactor","content":"&lt;/&gt; ExperienceCalculator.GetExperienceFactor() → number-- The current experience factor Gets the current experience scaling factor. Usage Notes: Useful for saving/loading game settings Returns the current factor being used for calculations Example: local currentFactor = ExperienceCalculator.GetExperienceFactor() print(&quot;Current XP factor:&quot;, currentFactor) -- 200   ","version":null,"tagName":"h3"},{"title":"GetLevel​","type":1,"pageTitle":"ExperienceCalculator","url":"/Mathf/api/ExperienceCalculator#GetLevel","content":"&lt;/&gt; ExperienceCalculator.GetLevel( experience: number-- Total accumulated experience points ) → number-- The current level (rounded down) Calculates the player's level based on their total accumulated experience. Usage Notes: Returns floor value (always rounds down) Works with any positive experience value Level 1 starts at 0 experience Safe to call with math.huge (returns maximum level) Example: local level = ExperienceCalculator.GetLevel(1000) print(&quot;Player is level:&quot;, level) -- e.g., 5   ","version":null,"tagName":"h3"},{"title":"GetExperienceRequiredForNextLevel​","type":1,"pageTitle":"ExperienceCalculator","url":"/Mathf/api/ExperienceCalculator#GetExperienceRequiredForNextLevel","content":"&lt;/&gt; ExperienceCalculator.GetExperienceRequiredForNextLevel( currentLevel: number-- The player's current level ) → number-- Total experience required to reach the next level Returns the total experience required to reach the next level from current level. Usage Notes: Input is the CURRENT level, not experience Result is the TOTAL experience needed for next level (not remaining) Use GetExperienceForNextLevel() to get remaining XP needed Example: local xpForLevel6 = ExperienceCalculator.GetExperienceRequiredForNextLevel(5) print(&quot;Total XP needed for level 6:&quot;, xpForLevel6)   ","version":null,"tagName":"h3"},{"title":"GetExperienceRequiredForLevel​","type":1,"pageTitle":"ExperienceCalculator","url":"/Mathf/api/ExperienceCalculator#GetExperienceRequiredForLevel","content":"&lt;/&gt; ExperienceCalculator.GetExperienceRequiredForLevel( level: number-- The target level ) → number-- Total experience required to reach that level Gets the total experience required to reach a specific level. Usage Notes: Input is the TARGET level you want to calculate for Returns cumulative XP needed from level 0 Useful for displaying level requirements in UI Example: local xpForLevel10 = ExperienceCalculator.GetExperienceRequiredForLevel(10) print(&quot;Total XP to reach level 10:&quot;, xpForLevel10)   ","version":null,"tagName":"h3"},{"title":"GetExperienceForNextLevel​","type":1,"pageTitle":"ExperienceCalculator","url":"/Mathf/api/ExperienceCalculator#GetExperienceForNextLevel","content":"&lt;/&gt; ExperienceCalculator.GetExperienceForNextLevel( currentExperience: number-- Player's current total experience ) → number-- Experience points remaining to reach next level Calculates how much more experience is needed to reach the next level. Usage Notes: Input is CURRENT experience, not level Returns remaining XP needed (not total required) Returns 0 if experience is infinite (math.huge) Useful for progress bars and &quot;XP to next level&quot; displays Example: local remaining = ExperienceCalculator.GetExperienceForNextLevel(1250) print(&quot;XP needed for next level:&quot;, remaining)   ","version":null,"tagName":"h3"},{"title":"GetSubExperience​","type":1,"pageTitle":"ExperienceCalculator","url":"/Mathf/api/ExperienceCalculator#GetSubExperience","content":"&lt;/&gt; ExperienceCalculator.GetSubExperience( currentExperience: number-- Player's current total experience ) → ( number,-- Experience achieved within current level number-- Total experience required for current level ) Calculates progress within the current level (for progress bars). Returns how much XP you've earned in current level and how much is needed total. Usage Notes: Perfect for progress bars: achieved/total gives you 0.0-1.0 percentage Returns (1, 1) if experience is infinite Both return values are always positive achieved will never exceed total Example: local achieved, total = ExperienceCalculator.GetSubExperience(1250) local percentage = achieved / total print(string.format(&quot;Level progress: %.1f%%&quot;, percentage * 100))   ","version":null,"tagName":"h3"},{"title":"GetExperienceBetweenLevels​","type":1,"pageTitle":"ExperienceCalculator","url":"/Mathf/api/ExperienceCalculator#GetExperienceBetweenLevels","content":"&lt;/&gt; ExperienceCalculator.GetExperienceBetweenLevels( fromLevel: number,-- Starting level toLevel: number-- Target level ) → number-- Experience difference between the two levels Calculates the experience difference between two levels. Useful for determining XP rewards or level gaps. Usage Notes: Can calculate forwards (level 5 to 10) or backwards (level 10 to 5) Returns absolute difference Useful for milestone rewards and catch-up mechanics Example: local xpGap = ExperienceCalculator.GetExperienceBetweenLevels(5, 10) print(&quot;XP needed to go from level 5 to 10:&quot;, xpGap)   ","version":null,"tagName":"h3"},{"title":"ProjectLevel​","type":1,"pageTitle":"ExperienceCalculator","url":"/Mathf/api/ExperienceCalculator#ProjectLevel","content":"&lt;/&gt; ExperienceCalculator.ProjectLevel( currentExperience: number,-- Current total experience experienceGain: number-- Experience to be added ) → number-- Projected level after gaining experience Calculates what level a player would reach after gaining specified experience. Usage Notes: Does not modify current experience, only projects the result Useful for &quot;what if&quot; calculations and reward previews Handles overflow safely Example: local futureLevel = ExperienceCalculator.ProjectLevel(1000, 500) print(&quot;After gaining 500 XP, you'll be level:&quot;, futureLevel)   ","version":null,"tagName":"h3"},{"title":"GetLevelProgressPercentage​","type":1,"pageTitle":"ExperienceCalculator","url":"/Mathf/api/ExperienceCalculator#GetLevelProgressPercentage","content":"&lt;/&gt; ExperienceCalculator.GetLevelProgressPercentage( currentExperience: number-- Player's current total experience ) → number-- Completion percentage (0-100) Calculates completion percentage of current level (0-100). Convenience function that combines GetSubExperience with percentage calculation. Usage Notes: Returns value between 0 and 100 Useful for UI displays without manual calculation Returns 100 if experience is infinite Example: local percent = ExperienceCalculator.GetLevelProgressPercentage(1250) print(string.format(&quot;Level progress: %.1f%%&quot;, percent))   ","version":null,"tagName":"h3"},{"title":"WillLevelUp​","type":1,"pageTitle":"ExperienceCalculator","url":"/Mathf/api/ExperienceCalculator#WillLevelUp","content":"&lt;/&gt; ExperienceCalculator.WillLevelUp( currentExperience: number,-- Experience before gain newExperience: number-- Experience after gain ) → boolean-- True if the experience gain causes a level up Validates if an experience value would cause a level up. Usage Notes: Useful for triggering level-up events and animations Check this before and after adding experience Returns false if either value is infinite Example: local oldXP = 1000 local newXP = 1500 if ExperienceCalculator.WillLevelUp(oldXP, newXP) then print(&quot;Level up!&quot;) end   ","version":null,"tagName":"h3"},{"title":"GenerateLevelTable​","type":1,"pageTitle":"ExperienceCalculator","url":"/Mathf/api/ExperienceCalculator#GenerateLevelTable","content":"&lt;/&gt; ExperienceCalculator.GenerateLevelTable( startLevel: number,-- First level in the table endLevel: number-- Last level in the table ) → table-- Dictionary mapping levels to experience requirements Generates a lookup table of experience requirements for a range of levels. Useful for caching and displaying level progression tables. Usage Notes: Computationally efficient for displaying multiple level requirements Returns a dictionary with level as key, XP as value Useful for leaderboards and progression UI Example: local table = ExperienceCalculator.GenerateLevelTable(1, 20) for level, xp in pairs(table) do print(string.format(&quot;Level %d: %d XP&quot;, level, xp)) end  ","version":null,"tagName":"h3"},{"title":"PhysicsUtil","type":0,"sectionRef":"#","url":"/Mathf/api/PhysicsUtil","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"PhysicsUtil","url":"/Mathf/api/PhysicsUtil#functions","content":" ","version":null,"tagName":"h2"},{"title":"SetWaterDensity​","type":1,"pageTitle":"PhysicsUtil","url":"/Mathf/api/PhysicsUtil#SetWaterDensity","content":"&lt;/&gt; PhysicsUtil.SetWaterDensity(newDensity: number) → () Standard water density constant used for buoyancy calculations. Usage Notes: Default value: 1 (mass/volume) Can be modified for different liquid densities Used in EstimateBuoyancyContribution calculations Real water density is ~1000 kg/m³, this is simplified for Roblox  ","version":null,"tagName":"h3"},{"title":"GetConnectedParts​","type":1,"pageTitle":"PhysicsUtil","url":"/Mathf/api/PhysicsUtil#GetConnectedParts","content":"&lt;/&gt; PhysicsUtil.GetConnectedParts( part: BasePart -- The part to get connections from ) → {BasePart }-- Array containing all connected parts plus the original part Retrieves all connected parts of a part, including the part itself. Usage Notes: Uses recursive connection detection Includes the original part in returned array Works with welded, hinged, and constraint-connected parts Useful for calculating properties of entire assemblies Example: local car = workspace.Vehicle.Chassis local allParts = PhysicsUtil.GetConnectedParts(car) print(&quot;Vehicle has&quot;, #allParts, &quot;parts&quot;)   ","version":null,"tagName":"h3"},{"title":"EstimateBuoyancyContribution​","type":1,"pageTitle":"PhysicsUtil","url":"/Mathf/api/PhysicsUtil#EstimateBuoyancyContribution","content":"&lt;/&gt; PhysicsUtil.EstimateBuoyancyContribution( parts: {BasePart }-- Array of parts to calculate buoyancy for ) → ( number,-- Total buoyancy force (positive = float, negative = sink) number,-- Total mass of all parts number-- Total volume of collidable parts ) Estimates the total buoyancy force contributed by a collection of parts. Usage Notes: Only CanCollide parts contribute to buoyancy displacement Returns negative values if object would sink Positive values indicate floating capability Uses workspace gravity for calculations Assumes parts are fully submerged Example: local boat = workspace.Boat local parts = PhysicsUtil.GetConnectedParts(boat.Hull) local buoyancy, mass, volume = PhysicsUtil.EstimateBuoyancyContribution(parts) if buoyancy &gt; 0 then print(&quot;Boat will float!&quot;) else print(&quot;Boat will sink!&quot;) end   ","version":null,"tagName":"h3"},{"title":"GetCenterOfMass​","type":1,"pageTitle":"PhysicsUtil","url":"/Mathf/api/PhysicsUtil#GetCenterOfMass","content":"&lt;/&gt; PhysicsUtil.GetCenterOfMass( parts: {BasePart }-- Array of parts to calculate center of mass for ) → ( Vector3 ,-- World position of center of mass number-- Total mass of all parts ) Calculates the world-space center of mass for a collection of parts. Usage Notes: Returns weighted average position based on part masses Essential for realistic physics simulation Used as pivot point for rotational physics More accurate than using geometric center Works with any collection of parts Example: local vehicle = workspace.Car local parts = PhysicsUtil.GetConnectedParts(vehicle.Chassis) local centerOfMass, totalMass = PhysicsUtil.GetCenterOfMass(parts) -- Visualize center of mass local sphere = Instance.new(&quot;Part&quot;) sphere.Shape = Enum.PartType.Ball sphere.Size = Vector3.new(1, 1, 1) sphere.Position = centerOfMass sphere.Anchored = true sphere.Parent = workspace   ","version":null,"tagName":"h3"},{"title":"MomentOfInertia​","type":1,"pageTitle":"PhysicsUtil","url":"/Mathf/api/PhysicsUtil#MomentOfInertia","content":"&lt;/&gt; PhysicsUtil.MomentOfInertia( part: BasePart ,-- The part to calculate inertia for axis: Vector3 ,-- Axis of rotation (does not need to be unit vector) origin: Vector3 -- Origin point of the rotation axis ) → number-- Moment of inertia around the specified axis Calculates the moment of inertia of a cuboid part around a given axis. Usage Notes: Moment of inertia represents resistance to rotational acceleration Higher values mean harder to rotate Takes into account both part shape and position relative to axis Uses parallel axis theorem for offset calculation Essential for realistic torque simulation Example: local part = workspace.Wheel local axis = Vector3.new(0, 1, 0) -- Rotation around Y axis local origin = part.Position local inertia = PhysicsUtil.MomentOfInertia(part, axis, origin) print(&quot;Rotational inertia:&quot;, inertia)   ","version":null,"tagName":"h3"},{"title":"BodyMomentOfInertia​","type":1,"pageTitle":"PhysicsUtil","url":"/Mathf/api/PhysicsUtil#BodyMomentOfInertia","content":"&lt;/&gt; PhysicsUtil.BodyMomentOfInertia( parts: {BasePart },-- Array of connected parts axis: Vector3 ,-- Rotation axis (typically torque vector) origin: Vector3 -- Origin of rotation (typically center of mass) ) → number-- Total moment of inertia for the entire body Calculates the total moment of inertia for a connected body of parts. Usage Notes: Sums individual part inertias for entire assembly Axis should be the torque vector or (offset × force) Origin should be the center of mass of the assembly Used for calculating angular acceleration from torque Essential for multi-part physics simulation Example: local robot = workspace.Robot local parts = PhysicsUtil.GetConnectedParts(robot.Torso) local com, mass = PhysicsUtil.GetCenterOfMass(parts) local torque = Vector3.new(0, 100, 0) -- Spin torque local inertia = PhysicsUtil.BodyMomentOfInertia(parts, torque, com) local angularAccel = torque / inertia   ","version":null,"tagName":"h3"},{"title":"ApplyForce​","type":1,"pageTitle":"PhysicsUtil","url":"/Mathf/api/PhysicsUtil#ApplyForce","content":"&lt;/&gt; PhysicsUtil.ApplyForce( part: BasePart ,-- The part to apply force to (can be any part in assembly) force: Vector3 ,-- Force vector to apply (in studs * mass / second²) forcePosition: Vector3? -- World position where force is applied (defaults to part.Position) ) → () Applies a force to a Roblox physics body at a specific position. Usage Notes: Automatically calculates both linear and angular acceleration Uses Newton's laws and rotational dynamics Works on entire connected assembly, not just one part Force position determines torque magnitude and direction Modifies both Velocity and RotVelocity properties Setting velocity on one part affects entire connected body in Roblox Physics Details: Linear acceleration = Force / Mass Torque = Offset × Force Angular acceleration = Torque / Moment of Inertia Example: -- Apply explosion force to a part local part = workspace.Crate local explosionPos = Vector3.new(0, 5, 0) local force = (part.Position - explosionPos).Unit * 1000 PhysicsUtil.ApplyForce(part, force, part.Position) -- Apply force at edge of part for spin effect local spinForce = Vector3.new(100, 0, 0) local edgePos = part.Position + Vector3.new(0, part.Size.Y/2, 0) PhysicsUtil.ApplyForce(part, spinForce, edgePos)   ","version":null,"tagName":"h3"},{"title":"AcceleratePart​","type":1,"pageTitle":"PhysicsUtil","url":"/Mathf/api/PhysicsUtil#AcceleratePart","content":"&lt;/&gt; PhysicsUtil.AcceleratePart( part: BasePart ,-- The part to accelerate emittingPart: BasePart ,-- The part that emits/launches the other part (receives recoil) acceleration: Vector3 -- Desired acceleration vector for the part ) → () Accelerates a part using Newton's third law (action-reaction). Usage Notes: Applies equal and opposite forces to both parts Useful for projectile systems and explosions EmittingPart receives recoil force Conserves momentum in the system Force magnitude calculated from part mass and desired acceleration Physics: Force = Mass × Acceleration Action force on part, reaction force on emittingPart Both parts affected by their respective connected assemblies Example: -- Cannon firing system local cannon = workspace.Cannon.Barrel local cannonball = workspace.Cannonball local acceleration = Vector3.new(0, 0, -500) -- Fire forward PhysicsUtil.AcceleratePart(cannonball, cannon, acceleration) -- Cannonball flies forward, cannon recoils backward -- Rocket propulsion local rocket = workspace.Rocket local exhaustPart = workspace.ExhaustParticle local thrust = Vector3.new(0, 1000, 0) -- Upward thrust PhysicsUtil.AcceleratePart(exhaustPart, rocket, -thrust)  ","version":null,"tagName":"h3"},{"title":"Mathf","type":0,"sectionRef":"#","url":"/Mathf/api/Mathf","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Mathf","url":"/Mathf/api/Mathf#functions","content":" ","version":null,"tagName":"h2"},{"title":"GetWeighedRandom​","type":1,"pageTitle":"Mathf","url":"/Mathf/api/Mathf#GetWeighedRandom","content":"&lt;/&gt; Mathf.GetWeighedRandom( tab: {[K]: number}-- Table with elements as keys and weights as values ) → K?-- Random element from the table, or nil if empty Returns a random element from the provided table, with weights for each element. Usage Notes: Higher weight values increase the probability of selection Weight of 0 means the element will never be selected Returns nil if the table is empty Total weight sum is calculated automatically Example: local items = { [&quot;Common&quot;] = 70, [&quot;Rare&quot;] = 25, [&quot;Legendary&quot;] = 5 } local result = Mathf.GetWeighedRandom(items) print(&quot;Got:&quot;, result) -- More likely to be &quot;Common&quot;   ","version":null,"tagName":"h3"},{"title":"FrameDelta​","type":1,"pageTitle":"Mathf","url":"/Mathf/api/Mathf#FrameDelta","content":"&lt;/&gt; Mathf.FrameDelta( mult: number,-- Animation speed multiplier (0-1 typical range) delta: number-- Frame delta time in seconds ) → number-- Adjusted delta value for smooth animation Calculates frame delta for smooth animation based on the provided multiplier and delta time. Usage Notes: Ensures consistent animation speed regardless of frame rate mult should be between 0 and 1 for typical use cases Works with RunService:BindToRenderStep or Heartbeat delta Formula compensates for variable frame rates Example: local position = 0 local target = 100 RunService.Heartbeat:Connect(function(delta) position += (target - position) * Mathf.FrameDelta(0.1, delta) end)   ","version":null,"tagName":"h3"},{"title":"RandomizeVector​","type":1,"pageTitle":"Mathf","url":"/Mathf/api/Mathf#RandomizeVector","content":"&lt;/&gt; Mathf.RandomizeVector( basisVector: Vector3 ,-- The base direction vector radianSpreadX: number,-- Maximum deviation in radians on X axis radianSpreadY: number-- Maximum deviation in radians on Y axis ) → Vector3 -- Randomized vector with same magnitude as input Randomly deviates a vector within specified radian spreads on X and Y axes. Usage Notes: Useful for bullet spread, cone effects, or particle dispersion Spreads are in radians (use math.rad() to convert from degrees) Maintains the original vector's magnitude Creates a cone of possible directions Example: local bulletDirection = Vector3.new(0, 0, -1) local spread = Mathf.RandomizeVector(bulletDirection, math.rad(5), math.rad(5)) -- Bullet will deviate up to 5 degrees in any direction   ","version":null,"tagName":"h3"},{"title":"SafeLerp​","type":1,"pageTitle":"Mathf","url":"/Mathf/api/Mathf#SafeLerp","content":"&lt;/&gt; Mathf.SafeLerp( a: number | Color3 ,-- Start value or color b: number | Color3 ,-- End value or color t: number-- Interpolation factor (0-1) ) → number | Color3 -- Interpolated value or color Safely interpolates between two values or colors, handling nil cases. Usage Notes: Returns b if a is nil or t &gt;= 1 Returns a if b is nil or t &lt;= 0 Uses gamma-correct interpolation for Color3 Safe to use with potentially undefined values Example: local color1 = Color3.new(1, 0, 0) -- Red local color2 = Color3.new(0, 0, 1) -- Blue local mixed = Mathf.SafeLerp(color1, color2, 0.5) -- Purple   ","version":null,"tagName":"h3"},{"title":"PercentBetween​","type":1,"pageTitle":"Mathf","url":"/Mathf/api/Mathf#PercentBetween","content":"&lt;/&gt; Mathf.PercentBetween( num: number,-- The value to evaluate min: number,-- Minimum bound max: number-- Maximum bound ) → number-- Percentage between 0 and 1 Calculates the percentage a number is between two other numbers. Usage Notes: Returns 0 if num &lt;= min Returns 1 if num &gt;= max Returns 1 if min equals max (prevents division by zero) Useful for progress bars and UI elements Example: local health = 75 local percent = Mathf.PercentBetween(health, 0, 100) print(percent) -- 0.75   ","version":null,"tagName":"h3"},{"title":"Round​","type":1,"pageTitle":"Mathf","url":"/Mathf/api/Mathf#Round","content":"&lt;/&gt; Mathf.Round( num: number,-- Number to round grid: number,-- Grid size for rounding offset: number?-- Rounding offset (default 0.5) ) → number-- Rounded value Rounds a number to the nearest grid value with optional offset. Usage Notes: Grid defines the rounding increment (e.g., 5 rounds to nearest 5) Offset adjusts rounding behavior (default 0.5 for standard rounding) Offset of 0 rounds down, 1 rounds up Useful for snap-to-grid mechanics Example: local rounded = Mathf.Round(23, 5) -- 25 local floored = Mathf.Round(23, 5, 0) -- 20   ","version":null,"tagName":"h3"},{"title":"RoundNumber​","type":1,"pageTitle":"Mathf","url":"/Mathf/api/Mathf#RoundNumber","content":"&lt;/&gt; Mathf.RoundNumber( x: number-- Number to round ) → number-- Nearest integer Rounds a number to the nearest integer. Usage Notes: Rounds 0.5 up for positive numbers Rounds -0.5 down for negative numbers Equivalent to Round(x, 1, 0.5) Faster than the generic Round function Example: print(Mathf.RoundNumber(3.7)) -- 4 print(Mathf.RoundNumber(-3.7)) -- -4   ","version":null,"tagName":"h3"},{"title":"Lerp​","type":1,"pageTitle":"Mathf","url":"/Mathf/api/Mathf#Lerp","content":"&lt;/&gt; Mathf.Lerp( a: number,-- Start value b: number,-- End value t: number-- Interpolation factor ) → number-- Interpolated value Linearly interpolates between two numbers. Usage Notes: t = 0 returns a t = 1 returns b t can be outside 0-1 range for extrapolation For clamped interpolation, use math.clamp on t Example: local start = 0 local finish = 100 local halfway = Mathf.Lerp(start, finish, 0.5) -- 50   ","version":null,"tagName":"h3"},{"title":"SmoothLerp​","type":1,"pageTitle":"Mathf","url":"/Mathf/api/Mathf#SmoothLerp","content":"&lt;/&gt; Mathf.SmoothLerp( a: number,-- Start value b: number,-- End value t: number-- Interpolation factor (0-1) ) → number-- Smoothly interpolated value Smoothly interpolates between two numbers using cosine interpolation. Usage Notes: Provides ease-in-ease-out effect Smoother than linear interpolation at edges Returns exact values at t=0 and t=1 (within epsilon) Uses cosine function for smooth curve Example: -- Animation with smooth start and end local position = Mathf.SmoothLerp(0, 100, progress)   ","version":null,"tagName":"h3"},{"title":"LerpTowards​","type":1,"pageTitle":"Mathf","url":"/Mathf/api/Mathf#LerpTowards","content":"&lt;/&gt; Mathf.LerpTowards( n: number,-- Current value g: number,-- Goal value t: number-- Maximum step size (positive) ) → number-- New value closer to goal Linearly interpolates towards a target number with a given step size. Usage Notes: Will not overshoot the goal t is the maximum distance to move, not a percentage Always moves closer to goal (or stays the same) Useful for smooth following behavior Example: local current = 10 local target = 100 current = Mathf.LerpTowards(current, target, 5) -- 15   ","version":null,"tagName":"h3"},{"title":"Wrap​","type":1,"pageTitle":"Mathf","url":"/Mathf/api/Mathf#Wrap","content":"&lt;/&gt; Mathf.Wrap( num: number,-- Number to wrap min: number,-- Minimum bound (inclusive) max: number-- Maximum bound (exclusive) ) → number-- Wrapped value Wraps a number within a range. Usage Notes: Range is [min, max) Works like modulo but for arbitrary ranges Handles negative numbers correctly Does not clamp, values wrap around Example: local angle = Mathf.Wrap(370, 0, 360) -- 10 local wrapped = Mathf.Wrap(-5, 0, 10) -- 5   ","version":null,"tagName":"h3"},{"title":"WrapIndex​","type":1,"pageTitle":"Mathf","url":"/Mathf/api/Mathf#WrapIndex","content":"&lt;/&gt; Mathf.WrapIndex( num: number,-- Index to wrap length: number-- Array length ) → number-- Wrapped index (1-based) Wraps an index within a given length (1-based indexing). Usage Notes: Designed for Lua's 1-based arrays Length 5 wraps to range [1, 5] Useful for circular buffers or looping arrays Handles negative indices correctly Example: local array = {10, 20, 30, 40, 50} local index = Mathf.WrapIndex(7, #array) -- 2 print(array[index]) -- 20   ","version":null,"tagName":"h3"},{"title":"Cubic_Interpolate​","type":1,"pageTitle":"Mathf","url":"/Mathf/api/Mathf#Cubic_Interpolate","content":"&lt;/&gt; Mathf.Cubic_Interpolate( v0: Vector3 ,-- Previous control point v1: Vector3 ,-- Start point v2: Vector3 ,-- End point v3: Vector3 ,-- Next control point x: number-- Interpolation factor (0-1) ) → Vector3 -- Interpolated position Performs cubic interpolation between four vectors. Usage Notes: Creates smooth curves through multiple points v1 and v2 are the interpolation segment v0 and v3 provide curve context x should be between 0 and 1 for segment v1-v2 Example: -- Smooth path through waypoints local points = {wp0, wp1, wp2, wp3} local position = Mathf.Cubic_Interpolate( points[1], points[2], points[3], points[4], 0.5 )   ","version":null,"tagName":"h3"},{"title":"Map​","type":1,"pageTitle":"Mathf","url":"/Mathf/api/Mathf#Map","content":"&lt;/&gt; Mathf.Map( num: number,-- Input value min0: number,-- Input range minimum max0: number,-- Input range maximum min1: number,-- Output range minimum max1: number-- Output range maximum ) → number-- Mapped value in output range Maps a number from one range to another. Usage Notes: Throws error if input range is zero (min0 == max0) Linear transformation between ranges Can extrapolate beyond target range if num outside input range Useful for converting between different value systems Example: -- Convert 0-100 health to 0-1 UI scale local healthPercent = Mathf.Map(75, 0, 100, 0, 1) -- 0.75 -- Convert temperature F to C local celsius = Mathf.Map(32, 32, 212, 0, 100) -- 0   ","version":null,"tagName":"h3"},{"title":"LawOfCosines​","type":1,"pageTitle":"Mathf","url":"/Mathf/api/Mathf#LawOfCosines","content":"&lt;/&gt; Mathf.LawOfCosines( a: number,-- Side length a b: number,-- Side length b c: number-- Side length c (opposite to returned angle) ) → number?-- Angle in radians, or nil if impossible Solves for angle across from side c using law of cosines. Usage Notes: Returns nil if triangle is impossible (invalid side lengths) Returns angle in radians All sides must be positive Useful for inverse kinematics and triangle solving Example: local angle = Mathf.LawOfCosines(3, 4, 5) if angle then print(math.deg(angle)) -- ~90 degrees for right triangle end   ","version":null,"tagName":"h3"},{"title":"RoundUp​","type":1,"pageTitle":"Mathf","url":"/Mathf/api/Mathf#RoundUp","content":"&lt;/&gt; Mathf.RoundUp( number: number,-- Number to round precision: number-- Rounding precision ) → number-- Rounded up value Rounds up to the nearest multiple of precision. Usage Notes: Always rounds towards positive infinity precision must be positive Useful for allocating memory or grid alignment Complements RoundDown Example: local rounded = Mathf.RoundUp(23, 5) -- 25 local rounded = Mathf.RoundUp(20, 5) -- 20   ","version":null,"tagName":"h3"},{"title":"RoundDown​","type":1,"pageTitle":"Mathf","url":"/Mathf/api/Mathf#RoundDown","content":"&lt;/&gt; Mathf.RoundDown( number: number,-- Number to round precision: number-- Rounding precision ) → number-- Rounded down value Rounds down to the nearest multiple of precision. Usage Notes: Always rounds towards negative infinity precision must be positive Useful for truncating to grid or quantizing values Complements RoundUp Example: local rounded = Mathf.RoundDown(23, 5) -- 20 local rounded = Mathf.RoundDown(20, 5) -- 20   ","version":null,"tagName":"h3"},{"title":"SlerpVector​","type":1,"pageTitle":"Mathf","url":"/Mathf/api/Mathf#SlerpVector","content":"&lt;/&gt; Mathf.SlerpVector( a: Vector3 ,-- Start vector b: Vector3 ,-- End vector t: number-- Interpolation factor (0-1) ) → Vector3 -- Spherically interpolated vector Spherically interpolates between two vectors. Usage Notes: Maintains constant length during interpolation Creates arc motion between vectors More natural than linear interpolation for rotations Result has same length as interpolated CFrame's LookVector Example: local lookDir = Vector3.new(1, 0, 0) local targetDir = Vector3.new(0, 1, 0) local smoothDir = Mathf.SlerpVector(lookDir, targetDir, 0.5) -- Result follows curved path, not straight line   ","version":null,"tagName":"h3"},{"title":"LerpColor3​","type":1,"pageTitle":"Mathf","url":"/Mathf/api/Mathf#LerpColor3","content":"&lt;/&gt; Mathf.LerpColor3( a: Color3 ,-- Start color b: Color3 ,-- End color t: number-- Interpolation factor (0-1) ) → Color3 -- Interpolated color Linearly interpolates between two colors using gamma-correct interpolation. Usage Notes: Uses perceptually correct interpolation (gamma space) Prevents colors from appearing too dark in middle More accurate than component-wise linear interpolation Same algorithm as SafeLerp for Color3 Example: local red = Color3.new(1, 0, 0) local blue = Color3.new(0, 0, 1) local purple = Mathf.LerpColor3(red, blue, 0.5)   ","version":null,"tagName":"h3"},{"title":"InPart​","type":1,"pageTitle":"Mathf","url":"/Mathf/api/Mathf#InPart","content":"&lt;/&gt; Mathf.InPart( part: BasePart ,-- Part to check against pos: Vector3 ,-- Position to test sizemult: number?-- Size multiplier (default 1) ) → boolean-- True if position is inside the part Checks if a position is within the bounding box of a part. Usage Notes: Works with rotated parts (uses CFrame space) sizemult scales the bounding box (1 = exact size) Does not account for part shape (treats all as boxes) Useful for trigger zones and collision detection Example: local isInside = Mathf.InPart(workspace.Zone, player.Position) -- Check with 10% margin local isNear = Mathf.InPart(workspace.Zone, player.Position, 1.1)   ","version":null,"tagName":"h3"},{"title":"ReflectVector​","type":1,"pageTitle":"Mathf","url":"/Mathf/api/Mathf#ReflectVector","content":"&lt;/&gt; Mathf.ReflectVector( vector: Vector3 ,-- Incident vector normal: Vector3 -- Surface normal ) → Vector3 -- Reflected vector Reflects a vector off a surface with the given normal. Usage Notes: Normal does not need to be unit length Returns vector with same magnitude as input Follows physics reflection formula Useful for bouncing projectiles or mirror effects Example: local velocity = Vector3.new(10, -10, 0) -- Moving down-right local ground = Vector3.new(0, 1, 0) -- Up normal local bounced = Mathf.ReflectVector(velocity, ground) -- Result: Vector3.new(10, 10, 0) - bounced up-right   ","version":null,"tagName":"h3"},{"title":"IK​","type":1,"pageTitle":"Mathf","url":"/Mathf/api/Mathf#IK","content":"&lt;/&gt; Mathf.IK( a: Vector3 ,-- Joint pivot position b: Vector3 ,-- End point target position l1: number,-- Length of first bone l2: number-- Length of second bone ) → ( CFrame ,-- Base orientation from a to b number,-- First joint angle in radians number-- Second joint angle in radians ) Solves inverse kinematics for a two-bone chain. Usage Notes: Returns base orientation and two joint angles Handles unreachable targets (fully extended) Handles targets too close (folded back) Angles are in radians Used for arm/leg IK systems Example: local shoulder = Vector3.new(0, 5, 0) local hand = Vector3.new(3, 2, 0) local upperArm = 2 local forearm = 2 local cf, angle1, angle2 = Mathf.IK(shoulder, hand, upperArm, forearm) -- Apply angles to joints   ","version":null,"tagName":"h3"},{"title":"Vector3ToPixel​","type":1,"pageTitle":"Mathf","url":"/Mathf/api/Mathf#Vector3ToPixel","content":"&lt;/&gt; Mathf.Vector3ToPixel( position: Vector3 ,-- World position to convert camera: Camera ,-- Camera instance reference: Frame -- UI frame for screen dimensions ) → ( number,-- Screen X coordinate in pixels number-- Screen Y coordinate in pixels ) Converts a world position to screen coordinates relative to a UI reference frame. Usage Notes: Returns pixel coordinates adjusted for camera roll Points behind camera return (20000, 20000) - off-screen Accounts for FOV and aspect ratio Subtracts 36 from Y for UI offset Reference frame provides screen dimensions Example: local camera = workspace.CurrentCamera local screenGui = player.PlayerGui.ScreenGui local x, y = Mathf.Vector3ToPixel( workspace.Target.Position, camera, screenGui.Frame ) -- Position UI element at world position   ","version":null,"tagName":"h3"},{"title":"LerpAngle​","type":1,"pageTitle":"Mathf","url":"/Mathf/api/Mathf#LerpAngle","content":"&lt;/&gt; Mathf.LerpAngle( a: number,-- Start angle in degrees b: number,-- End angle in degrees t: number-- Interpolation factor (0-1) ) → number-- Interpolated angle in degrees [-180, 180] Linearly interpolates between two angles in degrees. Usage Notes: Takes shortest path around circle Handles wrap-around at 360 degrees Returns angle in range [-180, 180] Works with any angle values (not limited to 0-360) Example: local from = 350 -- degrees local to = 10 -- degrees local mid = Mathf.LerpAngle(from, to, 0.5) -- 0 (not 180!)   ","version":null,"tagName":"h3"},{"title":"LerpRadAngle​","type":1,"pageTitle":"Mathf","url":"/Mathf/api/Mathf#LerpRadAngle","content":"&lt;/&gt; Mathf.LerpRadAngle( a1: number,-- Start angle in radians a2: number,-- End angle in radians percent: number-- Interpolation factor (0-1) ) → number-- Interpolated angle in radians [0, 2π] Linearly interpolates between two angles in radians. Usage Notes: Takes shortest path around circle Handles wrap-around at 2π Returns angle in range [0, 2π] Converts to degrees internally for calculation Example: local from = math.rad(350) local to = math.rad(10) local mid = Mathf.LerpRadAngle(from, to, 0.5) -- ~0 radians   ","version":null,"tagName":"h3"},{"title":"LerpTowardsAngle​","type":1,"pageTitle":"Mathf","url":"/Mathf/api/Mathf#LerpTowardsAngle","content":"&lt;/&gt; Mathf.LerpTowardsAngle( a1: number,-- Current angle in degrees a2: number,-- Target angle in degrees t: number-- Maximum step size in degrees ) → number-- New angle closer to target Linearly interpolates towards a target angle with a given step size. Usage Notes: Takes shortest path around circle Will not overshoot target t is maximum degrees to move, not percentage Handles angle wrap-around automatically Example: local current = 350 local target = 10 current = Mathf.LerpTowardsAngle(current, target, 5) -- 355 -- Next frame: 0, then 5, then 10 (stops at target)   ","version":null,"tagName":"h3"},{"title":"LerpAngle2​","type":1,"pageTitle":"Mathf","url":"/Mathf/api/Mathf#LerpAngle2","content":"&lt;/&gt; Mathf.LerpAngle2( a1: number,-- Start angle in degrees a2: number,-- End angle in degrees percent: number-- Interpolation factor (0-1) ) → number-- Interpolated angle in degrees [-180, 180] Linearly interpolates between two angles in degrees with adjusted range [-180, 180]. Usage Notes: Similar to LerpAngle but uses different normalization Takes shortest path around circle Returns angle in range [-180, 180] Adds 180 offset during calculation Example: local from = 170 local to = -170 local mid = Mathf.LerpAngle2(from, to, 0.5) -- 180 or -180   ","version":null,"tagName":"h3"},{"title":"AngleDistance​","type":1,"pageTitle":"Mathf","url":"/Mathf/api/Mathf#AngleDistance","content":"&lt;/&gt; Mathf.AngleDistance( a1: number,-- First angle in radians a2: number-- Second angle in radians ) → number-- Angular distance in radians Calculates the shortest angular distance between two angles in degrees. Usage Notes: Returns signed distance (positive or negative) Takes shortest path around circle Result in radians despite input in degrees Useful for determining rotation direction Example: local current = 10 local target = 350 local distance = Mathf.AngleDistance( math.rad(current), math.rad(target) ) -- Negative value means rotate counter-clockwise   ","version":null,"tagName":"h3"},{"title":"InterpolateCFrame​","type":1,"pageTitle":"Mathf","url":"/Mathf/api/Mathf#InterpolateCFrame","content":"&lt;/&gt; Mathf.InterpolateCFrame( CF1: CFrame ,-- Start CFrame CF2: CFrame ,-- End CFrame percent: number-- Interpolation factor (0-1) ) → CFrame -- Interpolated CFrame Interpolates between two CFrames. Usage Notes: Returns exact values at t=0 and t=1 (within epsilon) Interpolates both position and rotation Uses CFrame:Lerp internally Optimized to skip calculation at extremes Example: local start = CFrame.new(0, 0, 0) local finish = CFrame.new(10, 0, 0) * CFrame.Angles(0, math.pi, 0) local middle = Mathf.InterpolateCFrame(start, finish, 0.5) part.CFrame = middle  ","version":null,"tagName":"h3"}],"options":{"id":"default"}}