"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[345],{720:e=>{e.exports=JSON.parse('{"functions":[{"name":"GetWeighedRandom","desc":"Returns a random element from the provided table, with weights for each element.\\n\\n**Usage Notes:**\\n- Higher weight values increase the probability of selection\\n- Weight of 0 means the element will never be selected\\n- Returns nil if the table is empty\\n- Total weight sum is calculated automatically\\n\\n**Example:**\\n```lua\\nlocal items = {\\n\\t[\\"Common\\"] = 70,\\n\\t[\\"Rare\\"] = 25,\\n\\t[\\"Legendary\\"] = 5\\n}\\nlocal result = Mathf.GetWeighedRandom(items)\\nprint(\\"Got:\\", result) -- More likely to be \\"Common\\"\\n```","params":[{"name":"tab","desc":"Table with elements as keys and weights as values","lua_type":"{ [K]: number }"}],"returns":[{"desc":"Random element from the table, or nil if empty","lua_type":"K?"}],"function_type":"static","source":{"line":41,"path":"src/Mathf/init.luau"}},{"name":"FrameDelta","desc":"Calculates frame delta for smooth animation based on the provided multiplier and delta time.\\n\\n**Usage Notes:**\\n- Ensures consistent animation speed regardless of frame rate\\n- mult should be between 0 and 1 for typical use cases\\n- Works with RunService:BindToRenderStep or Heartbeat delta\\n- Formula compensates for variable frame rates\\n\\n**Example:**\\n```lua\\nlocal position = 0\\nlocal target = 100\\nRunService.Heartbeat:Connect(function(delta)\\n\\tposition += (target - position) * Mathf.FrameDelta(0.1, delta)\\nend)\\n```","params":[{"name":"mult","desc":"Animation speed multiplier (0-1 typical range)","lua_type":"number"},{"name":"delta","desc":"Frame delta time in seconds","lua_type":"number"}],"returns":[{"desc":"Adjusted delta value for smooth animation","lua_type":"number"}],"function_type":"static","source":{"line":83,"path":"src/Mathf/init.luau"}},{"name":"RandomizeVector","desc":"Randomly deviates a vector within specified radian spreads on X and Y axes.\\n\\n**Usage Notes:**\\n- Useful for bullet spread, cone effects, or particle dispersion\\n- Spreads are in radians (use math.rad() to convert from degrees)\\n- Maintains the original vector\'s magnitude\\n- Creates a cone of possible directions\\n\\n**Example:**\\n```lua\\nlocal bulletDirection = Vector3.new(0, 0, -1)\\nlocal spread = Mathf.RandomizeVector(bulletDirection, math.rad(5), math.rad(5))\\n-- Bullet will deviate up to 5 degrees in any direction\\n```","params":[{"name":"basisVector","desc":"The base direction vector","lua_type":"Vector3"},{"name":"radianSpreadX","desc":"Maximum deviation in radians on X axis","lua_type":"number"},{"name":"radianSpreadY","desc":"Maximum deviation in radians on Y axis","lua_type":"number"}],"returns":[{"desc":"Randomized vector with same magnitude as input","lua_type":"Vector3"}],"function_type":"static","source":{"line":109,"path":"src/Mathf/init.luau"}},{"name":"SafeLerp","desc":"Safely interpolates between two values or colors, handling nil cases.\\n\\n**Usage Notes:**\\n- Returns b if a is nil or t >= 1\\n- Returns a if b is nil or t <= 0\\n- Uses gamma-correct interpolation for Color3\\n- Safe to use with potentially undefined values\\n\\n**Example:**\\n```lua\\nlocal color1 = Color3.new(1, 0, 0) -- Red\\nlocal color2 = Color3.new(0, 0, 1) -- Blue\\nlocal mixed = Mathf.SafeLerp(color1, color2, 0.5) -- Purple\\n```","params":[{"name":"a","desc":"Start value or color","lua_type":"number | Color3"},{"name":"b","desc":"End value or color","lua_type":"number | Color3"},{"name":"t","desc":"Interpolation factor (0-1)","lua_type":"number"}],"returns":[{"desc":"Interpolated value or color","lua_type":"number | Color3"}],"function_type":"static","source":{"line":140,"path":"src/Mathf/init.luau"}},{"name":"PercentBetween","desc":"Calculates the percentage a number is between two other numbers.\\n\\n**Usage Notes:**\\n- Returns 0 if num <= min\\n- Returns 1 if num >= max\\n- Returns 1 if min equals max (prevents division by zero)\\n- Useful for progress bars and UI elements\\n\\n**Example:**\\n```lua\\nlocal health = 75\\nlocal percent = Mathf.PercentBetween(health, 0, 100)\\nprint(percent) -- 0.75\\n```","params":[{"name":"num","desc":"The value to evaluate","lua_type":"number"},{"name":"min","desc":"Minimum bound","lua_type":"number"},{"name":"max","desc":"Maximum bound","lua_type":"number"}],"returns":[{"desc":"Percentage between 0 and 1","lua_type":"number"}],"function_type":"static","source":{"line":183,"path":"src/Mathf/init.luau"}},{"name":"Round","desc":"Rounds a number to the nearest grid value with optional offset.\\n\\n**Usage Notes:**\\n- Grid defines the rounding increment (e.g., 5 rounds to nearest 5)\\n- Offset adjusts rounding behavior (default 0.5 for standard rounding)\\n- Offset of 0 rounds down, 1 rounds up\\n- Useful for snap-to-grid mechanics\\n\\n**Example:**\\n```lua\\nlocal rounded = Mathf.Round(23, 5) -- 25\\nlocal floored = Mathf.Round(23, 5, 0) -- 20\\n```","params":[{"name":"num","desc":"Number to round","lua_type":"number"},{"name":"grid","desc":"Grid size for rounding","lua_type":"number"},{"name":"offset","desc":"Rounding offset (default 0.5)","lua_type":"number?"}],"returns":[{"desc":"Rounded value","lua_type":"number"}],"function_type":"static","source":{"line":207,"path":"src/Mathf/init.luau"}},{"name":"RoundNumber","desc":"Rounds a number to the nearest integer.\\n\\n**Usage Notes:**\\n- Rounds 0.5 up for positive numbers\\n- Rounds -0.5 down for negative numbers\\n- Equivalent to Round(x, 1, 0.5)\\n- Faster than the generic Round function\\n\\n**Example:**\\n```lua\\nprint(Mathf.RoundNumber(3.7)) -- 4\\nprint(Mathf.RoundNumber(-3.7)) -- -4\\n```","params":[{"name":"x","desc":"Number to round","lua_type":"number"}],"returns":[{"desc":"Nearest integer","lua_type":"number"}],"function_type":"static","source":{"line":229,"path":"src/Mathf/init.luau"}},{"name":"Lerp","desc":"Linearly interpolates between two numbers.\\n\\n**Usage Notes:**\\n- t = 0 returns a\\n- t = 1 returns b\\n- t can be outside 0-1 range for extrapolation\\n- For clamped interpolation, use math.clamp on t\\n\\n**Example:**\\n```lua\\nlocal start = 0\\nlocal finish = 100\\nlocal halfway = Mathf.Lerp(start, finish, 0.5) -- 50\\n```","params":[{"name":"a","desc":"Start value","lua_type":"number"},{"name":"b","desc":"End value","lua_type":"number"},{"name":"t","desc":"Interpolation factor","lua_type":"number"}],"returns":[{"desc":"Interpolated value","lua_type":"number"}],"function_type":"static","source":{"line":254,"path":"src/Mathf/init.luau"}},{"name":"SmoothLerp","desc":"Smoothly interpolates between two numbers using cosine interpolation.\\n\\n**Usage Notes:**\\n- Provides ease-in-ease-out effect\\n- Smoother than linear interpolation at edges\\n- Returns exact values at t=0 and t=1 (within epsilon)\\n- Uses cosine function for smooth curve\\n\\n**Example:**\\n```lua\\n-- Animation with smooth start and end\\nlocal position = Mathf.SmoothLerp(0, 100, progress)\\n```","params":[{"name":"a","desc":"Start value","lua_type":"number"},{"name":"b","desc":"End value","lua_type":"number"},{"name":"t","desc":"Interpolation factor (0-1)","lua_type":"number"}],"returns":[{"desc":"Smoothly interpolated value","lua_type":"number"}],"function_type":"static","source":{"line":278,"path":"src/Mathf/init.luau"}},{"name":"LerpTowards","desc":"Linearly interpolates towards a target number with a given step size.\\n\\n**Usage Notes:**\\n- Will not overshoot the goal\\n- t is the maximum distance to move, not a percentage\\n- Always moves closer to goal (or stays the same)\\n- Useful for smooth following behavior\\n\\n**Example:**\\n```lua\\nlocal current = 10\\nlocal target = 100\\ncurrent = Mathf.LerpTowards(current, target, 5) -- 15\\n```","params":[{"name":"n","desc":"Current value","lua_type":"number"},{"name":"g","desc":"Goal value","lua_type":"number"},{"name":"t","desc":"Maximum step size (positive)","lua_type":"number"}],"returns":[{"desc":"New value closer to goal","lua_type":"number"}],"function_type":"static","source":{"line":303,"path":"src/Mathf/init.luau"}},{"name":"Wrap","desc":"Wraps a number within a range.\\n\\n**Usage Notes:**\\n- Range is [min, max)\\n- Works like modulo but for arbitrary ranges\\n- Handles negative numbers correctly\\n- Does not clamp, values wrap around\\n\\n**Example:**\\n```lua\\nlocal angle = Mathf.Wrap(370, 0, 360) -- 10\\nlocal wrapped = Mathf.Wrap(-5, 0, 10) -- 5\\n```","params":[{"name":"num","desc":"Number to wrap","lua_type":"number"},{"name":"min","desc":"Minimum bound (inclusive)","lua_type":"number"},{"name":"max","desc":"Maximum bound (exclusive)","lua_type":"number"}],"returns":[{"desc":"Wrapped value","lua_type":"number"}],"function_type":"static","source":{"line":331,"path":"src/Mathf/init.luau"}},{"name":"WrapIndex","desc":"Wraps an index within a given length (1-based indexing).\\n\\n**Usage Notes:**\\n- Designed for Lua\'s 1-based arrays\\n- Length 5 wraps to range [1, 5]\\n- Useful for circular buffers or looping arrays\\n- Handles negative indices correctly\\n\\n**Example:**\\n```lua\\nlocal array = {10, 20, 30, 40, 50}\\nlocal index = Mathf.WrapIndex(7, #array) -- 2\\nprint(array[index]) -- 20\\n```","params":[{"name":"num","desc":"Index to wrap","lua_type":"number"},{"name":"length","desc":"Array length","lua_type":"number"}],"returns":[{"desc":"Wrapped index (1-based)","lua_type":"number"}],"function_type":"static","source":{"line":355,"path":"src/Mathf/init.luau"}},{"name":"Cubic_Interpolate","desc":"Performs cubic interpolation between four vectors.\\n\\n**Usage Notes:**\\n- Creates smooth curves through multiple points\\n- v1 and v2 are the interpolation segment\\n- v0 and v3 provide curve context\\n- x should be between 0 and 1 for segment v1-v2\\n\\n**Example:**\\n```lua\\n-- Smooth path through waypoints\\nlocal points = {wp0, wp1, wp2, wp3}\\nlocal position = Mathf.Cubic_Interpolate(\\n\\tpoints[1], points[2], points[3], points[4], 0.5\\n)\\n```","params":[{"name":"v0","desc":"Previous control point","lua_type":"Vector3"},{"name":"v1","desc":"Start point","lua_type":"Vector3"},{"name":"v2","desc":"End point","lua_type":"Vector3"},{"name":"v3","desc":"Next control point","lua_type":"Vector3"},{"name":"x","desc":"Interpolation factor (0-1)","lua_type":"number"}],"returns":[{"desc":"Interpolated position","lua_type":"Vector3"}],"function_type":"static","source":{"line":384,"path":"src/Mathf/init.luau"}},{"name":"Map","desc":"Maps a number from one range to another.\\n\\n**Usage Notes:**\\n- Throws error if input range is zero (min0 == max0)\\n- Linear transformation between ranges\\n- Can extrapolate beyond target range if num outside input range\\n- Useful for converting between different value systems\\n\\n**Example:**\\n```lua\\n-- Convert 0-100 health to 0-1 UI scale\\nlocal healthPercent = Mathf.Map(75, 0, 100, 0, 1) -- 0.75\\n-- Convert temperature F to C\\nlocal celsius = Mathf.Map(32, 32, 212, 0, 100) -- 0\\n```","params":[{"name":"num","desc":"Input value","lua_type":"number"},{"name":"min0","desc":"Input range minimum","lua_type":"number"},{"name":"max0","desc":"Input range maximum","lua_type":"number"},{"name":"min1","desc":"Output range minimum","lua_type":"number"},{"name":"max1","desc":"Output range maximum","lua_type":"number"}],"returns":[{"desc":"Mapped value in output range","lua_type":"number"}],"function_type":"static","source":{"line":417,"path":"src/Mathf/init.luau"}},{"name":"LawOfCosines","desc":"Solves for angle across from side c using law of cosines.\\n\\n**Usage Notes:**\\n- Returns nil if triangle is impossible (invalid side lengths)\\n- Returns angle in radians\\n- All sides must be positive\\n- Useful for inverse kinematics and triangle solving\\n\\n**Example:**\\n```lua\\nlocal angle = Mathf.LawOfCosines(3, 4, 5)\\nif angle then\\n\\tprint(math.deg(angle)) -- ~90 degrees for right triangle\\nend\\n```","params":[{"name":"a","desc":"Side length a","lua_type":"number"},{"name":"b","desc":"Side length b","lua_type":"number"},{"name":"c","desc":"Side length c (opposite to returned angle)","lua_type":"number"}],"returns":[{"desc":"Angle in radians, or nil if impossible","lua_type":"number?"}],"function_type":"static","source":{"line":447,"path":"src/Mathf/init.luau"}},{"name":"RoundUp","desc":"Rounds up to the nearest multiple of precision.\\n\\n**Usage Notes:**\\n- Always rounds towards positive infinity\\n- precision must be positive\\n- Useful for allocating memory or grid alignment\\n- Complements RoundDown\\n\\n**Example:**\\n```lua\\nlocal rounded = Mathf.RoundUp(23, 5) -- 25\\nlocal rounded = Mathf.RoundUp(20, 5) -- 20\\n```","params":[{"name":"number","desc":"Number to round","lua_type":"number"},{"name":"precision","desc":"Rounding precision","lua_type":"number"}],"returns":[{"desc":"Rounded up value","lua_type":"number"}],"function_type":"static","source":{"line":475,"path":"src/Mathf/init.luau"}},{"name":"RoundDown","desc":"Rounds down to the nearest multiple of precision.\\n\\n**Usage Notes:**\\n- Always rounds towards negative infinity\\n- precision must be positive\\n- Useful for truncating to grid or quantizing values\\n- Complements RoundUp\\n\\n**Example:**\\n```lua\\nlocal rounded = Mathf.RoundDown(23, 5) -- 20\\nlocal rounded = Mathf.RoundDown(20, 5) -- 20\\n```","params":[{"name":"number","desc":"Number to round","lua_type":"number"},{"name":"precision","desc":"Rounding precision","lua_type":"number"}],"returns":[{"desc":"Rounded down value","lua_type":"number"}],"function_type":"static","source":{"line":498,"path":"src/Mathf/init.luau"}},{"name":"SlerpVector","desc":"Spherically interpolates between two vectors.\\n\\n**Usage Notes:**\\n- Maintains constant length during interpolation\\n- Creates arc motion between vectors\\n- More natural than linear interpolation for rotations\\n- Result has same length as interpolated CFrame\'s LookVector\\n\\n**Example:**\\n```lua\\nlocal lookDir = Vector3.new(1, 0, 0)\\nlocal targetDir = Vector3.new(0, 1, 0)\\nlocal smoothDir = Mathf.SlerpVector(lookDir, targetDir, 0.5)\\n-- Result follows curved path, not straight line\\n```","params":[{"name":"a","desc":"Start vector","lua_type":"Vector3"},{"name":"b","desc":"End vector","lua_type":"Vector3"},{"name":"t","desc":"Interpolation factor (0-1)","lua_type":"number"}],"returns":[{"desc":"Spherically interpolated vector","lua_type":"Vector3"}],"function_type":"static","source":{"line":526,"path":"src/Mathf/init.luau"}},{"name":"LerpColor3","desc":"Linearly interpolates between two colors using gamma-correct interpolation.\\n\\n**Usage Notes:**\\n- Uses perceptually correct interpolation (gamma space)\\n- Prevents colors from appearing too dark in middle\\n- More accurate than component-wise linear interpolation\\n- Same algorithm as SafeLerp for Color3\\n\\n**Example:**\\n```lua\\nlocal red = Color3.new(1, 0, 0)\\nlocal blue = Color3.new(0, 0, 1)\\nlocal purple = Mathf.LerpColor3(red, blue, 0.5)\\n```","params":[{"name":"a","desc":"Start color","lua_type":"Color3"},{"name":"b","desc":"End color","lua_type":"Color3"},{"name":"t","desc":"Interpolation factor (0-1)","lua_type":"number"}],"returns":[{"desc":"Interpolated color","lua_type":"Color3"}],"function_type":"static","source":{"line":553,"path":"src/Mathf/init.luau"}},{"name":"InPart","desc":"Checks if a position is within the bounding box of a part.\\n\\n**Usage Notes:**\\n- Works with rotated parts (uses CFrame space)\\n- sizemult scales the bounding box (1 = exact size)\\n- Does not account for part shape (treats all as boxes)\\n- Useful for trigger zones and collision detection\\n\\n**Example:**\\n```lua\\nlocal isInside = Mathf.InPart(workspace.Zone, player.Position)\\n-- Check with 10% margin\\nlocal isNear = Mathf.InPart(workspace.Zone, player.Position, 1.1)\\n```","params":[{"name":"part","desc":"Part to check against","lua_type":"BasePart"},{"name":"pos","desc":"Position to test","lua_type":"Vector3"},{"name":"sizemult","desc":"Size multiplier (default 1)","lua_type":"number?"}],"returns":[{"desc":"True if position is inside the part","lua_type":"boolean"}],"function_type":"static","source":{"line":586,"path":"src/Mathf/init.luau"}},{"name":"ReflectVector","desc":"Reflects a vector off a surface with the given normal.\\n\\n**Usage Notes:**\\n- Normal does not need to be unit length\\n- Returns vector with same magnitude as input\\n- Follows physics reflection formula\\n- Useful for bouncing projectiles or mirror effects\\n\\n**Example:**\\n```lua\\nlocal velocity = Vector3.new(10, -10, 0) -- Moving down-right\\nlocal ground = Vector3.new(0, 1, 0) -- Up normal\\nlocal bounced = Mathf.ReflectVector(velocity, ground)\\n-- Result: Vector3.new(10, 10, 0) - bounced up-right\\n```","params":[{"name":"vector","desc":"Incident vector","lua_type":"Vector3"},{"name":"normal","desc":"Surface normal","lua_type":"Vector3"}],"returns":[{"desc":"Reflected vector","lua_type":"Vector3"}],"function_type":"static","source":{"line":615,"path":"src/Mathf/init.luau"}},{"name":"IK","desc":"Solves inverse kinematics for a two-bone chain.\\n\\n**Usage Notes:**\\n- Returns base orientation and two joint angles\\n- Handles unreachable targets (fully extended)\\n- Handles targets too close (folded back)\\n- Angles are in radians\\n- Used for arm/leg IK systems\\n\\n**Example:**\\n```lua\\nlocal shoulder = Vector3.new(0, 5, 0)\\nlocal hand = Vector3.new(3, 2, 0)\\nlocal upperArm = 2\\nlocal forearm = 2\\nlocal cf, angle1, angle2 = Mathf.IK(shoulder, hand, upperArm, forearm)\\n-- Apply angles to joints\\n```","params":[{"name":"a","desc":"Joint pivot position","lua_type":"Vector3"},{"name":"b","desc":"End point target position","lua_type":"Vector3"},{"name":"l1","desc":"Length of first bone","lua_type":"number"},{"name":"l2","desc":"Length of second bone","lua_type":"number"}],"returns":[{"desc":"Base orientation from a to b","lua_type":"CFrame"},{"desc":"First joint angle in radians","lua_type":"number"},{"desc":"Second joint angle in radians","lua_type":"number"}],"function_type":"static","source":{"line":649,"path":"src/Mathf/init.luau"}},{"name":"Vector3ToPixel","desc":"Converts a world position to screen coordinates relative to a UI reference frame.\\n\\n**Usage Notes:**\\n- Returns pixel coordinates adjusted for camera roll\\n- Points behind camera return (20000, 20000) - off-screen\\n- Accounts for FOV and aspect ratio\\n- Subtracts 36 from Y for UI offset\\n- Reference frame provides screen dimensions\\n\\n**Example:**\\n```lua\\nlocal camera = workspace.CurrentCamera\\nlocal screenGui = player.PlayerGui.ScreenGui\\nlocal x, y = Mathf.Vector3ToPixel(\\n\\tworkspace.Target.Position,\\n\\tcamera,\\n\\tscreenGui.Frame\\n)\\n-- Position UI element at world position\\n```","params":[{"name":"position","desc":"World position to convert","lua_type":"Vector3"},{"name":"camera","desc":"Camera instance","lua_type":"Camera"},{"name":"reference","desc":"UI frame for screen dimensions","lua_type":"Frame"}],"returns":[{"desc":"Screen X coordinate in pixels","lua_type":"number"},{"desc":"Screen Y coordinate in pixels","lua_type":"number"}],"function_type":"static","source":{"line":702,"path":"src/Mathf/init.luau"}},{"name":"LerpAngle","desc":"Linearly interpolates between two angles in degrees.\\n\\n**Usage Notes:**\\n- Takes shortest path around circle\\n- Handles wrap-around at 360 degrees\\n- Returns angle in range [-180, 180]\\n- Works with any angle values (not limited to 0-360)\\n\\n**Example:**\\n```lua\\nlocal from = 350 -- degrees\\nlocal to = 10 -- degrees\\nlocal mid = Mathf.LerpAngle(from, to, 0.5) -- 0 (not 180!)\\n```","params":[{"name":"a","desc":"Start angle in degrees","lua_type":"number"},{"name":"b","desc":"End angle in degrees","lua_type":"number"},{"name":"t","desc":"Interpolation factor (0-1)","lua_type":"number"}],"returns":[{"desc":"Interpolated angle in degrees [-180, 180]","lua_type":"number"}],"function_type":"static","source":{"line":739,"path":"src/Mathf/init.luau"}},{"name":"LerpRadAngle","desc":"Linearly interpolates between two angles in radians.\\n\\n**Usage Notes:**\\n- Takes shortest path around circle\\n- Handles wrap-around at 2\u03c0\\n- Returns angle in range [0, 2\u03c0]\\n- Converts to degrees internally for calculation\\n\\n**Example:**\\n```lua\\nlocal from = math.rad(350)\\nlocal to = math.rad(10)\\nlocal mid = Mathf.LerpRadAngle(from, to, 0.5) -- ~0 radians\\n```","params":[{"name":"a1","desc":"Start angle in radians","lua_type":"number"},{"name":"a2","desc":"End angle in radians","lua_type":"number"},{"name":"percent","desc":"Interpolation factor (0-1)","lua_type":"number"}],"returns":[{"desc":"Interpolated angle in radians [0, 2\u03c0]","lua_type":"number"}],"function_type":"static","source":{"line":777,"path":"src/Mathf/init.luau"}},{"name":"LerpTowardsAngle","desc":"Linearly interpolates towards a target angle with a given step size.\\n\\n**Usage Notes:**\\n- Takes shortest path around circle\\n- Will not overshoot target\\n- t is maximum degrees to move, not percentage\\n- Handles angle wrap-around automatically\\n\\n**Example:**\\n```lua\\nlocal current = 350\\nlocal target = 10\\ncurrent = Mathf.LerpTowardsAngle(current, target, 5) -- 355\\n-- Next frame: 0, then 5, then 10 (stops at target)\\n```","params":[{"name":"a1","desc":"Current angle in degrees","lua_type":"number"},{"name":"a2","desc":"Target angle in degrees","lua_type":"number"},{"name":"t","desc":"Maximum step size in degrees","lua_type":"number"}],"returns":[{"desc":"New angle closer to target","lua_type":"number"}],"function_type":"static","source":{"line":816,"path":"src/Mathf/init.luau"}},{"name":"LerpAngle2","desc":"Linearly interpolates between two angles in degrees with adjusted range [-180, 180].\\n\\n**Usage Notes:**\\n- Similar to LerpAngle but uses different normalization\\n- Takes shortest path around circle\\n- Returns angle in range [-180, 180]\\n- Adds 180 offset during calculation\\n\\n**Example:**\\n```lua\\nlocal from = 170\\nlocal to = -170\\nlocal mid = Mathf.LerpAngle2(from, to, 0.5) -- 180 or -180\\n```","params":[{"name":"a1","desc":"Start angle in degrees","lua_type":"number"},{"name":"a2","desc":"End angle in degrees","lua_type":"number"},{"name":"percent","desc":"Interpolation factor (0-1)","lua_type":"number"}],"returns":[{"desc":"Interpolated angle in degrees [-180, 180]","lua_type":"number"}],"function_type":"static","source":{"line":849,"path":"src/Mathf/init.luau"}},{"name":"AngleDistance","desc":"Calculates the shortest angular distance between two angles in degrees.\\n\\n**Usage Notes:**\\n- Returns signed distance (positive or negative)\\n- Takes shortest path around circle\\n- Result in radians despite input in degrees\\n- Useful for determining rotation direction\\n\\n**Example:**\\n```lua\\nlocal current = 10\\nlocal target = 350\\nlocal distance = Mathf.AngleDistance(\\n\\tmath.rad(current),\\n\\tmath.rad(target)\\n)\\n-- Negative value means rotate counter-clockwise\\n```","params":[{"name":"a1","desc":"First angle in radians","lua_type":"number"},{"name":"a2","desc":"Second angle in radians","lua_type":"number"}],"returns":[{"desc":"Angular distance in radians","lua_type":"number"}],"function_type":"static","source":{"line":890,"path":"src/Mathf/init.luau"}},{"name":"InterpolateCFrame","desc":"Interpolates between two CFrames.\\n\\n**Usage Notes:**\\n- Returns exact values at t=0 and t=1 (within epsilon)\\n- Interpolates both position and rotation\\n- Uses CFrame:Lerp internally\\n- Optimized to skip calculation at extremes\\n\\n**Example:**\\n```lua\\nlocal start = CFrame.new(0, 0, 0)\\nlocal finish = CFrame.new(10, 0, 0) * CFrame.Angles(0, math.pi, 0)\\nlocal middle = Mathf.InterpolateCFrame(start, finish, 0.5)\\npart.CFrame = middle\\n```","params":[{"name":"CF1","desc":"Start CFrame","lua_type":"CFrame"},{"name":"CF2","desc":"End CFrame","lua_type":"CFrame"},{"name":"percent","desc":"Interpolation factor (0-1)","lua_type":"number"}],"returns":[{"desc":"Interpolated CFrame","lua_type":"CFrame"}],"function_type":"static","source":{"line":927,"path":"src/Mathf/init.luau"}}],"properties":[],"types":[],"name":"Mathf","desc":"","source":{"line":8,"path":"src/Mathf/init.luau"}}')}}]);