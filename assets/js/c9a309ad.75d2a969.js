"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[529],{4385:e=>{e.exports=JSON.parse('{"functions":[{"name":"SetWaterDensity","desc":"Standard water density constant used for buoyancy calculations.\\n\\n**Usage Notes:**\\n- Default value: 1 (mass/volume)\\n- Can be modified for different liquid densities\\n- Used in EstimateBuoyancyContribution calculations\\n- Real water density is ~1000 kg/m\xb3, this is simplified for Roblox","params":[{"name":"newDensity","desc":"","lua_type":"number"}],"returns":[],"function_type":"static","source":{"line":23,"path":"src/Mathf/PhysicsUtil.luau"}},{"name":"GetConnectedParts","desc":"Retrieves all connected parts of a part, including the part itself.\\n\\n**Usage Notes:**\\n- Uses recursive connection detection\\n- Includes the original part in returned array\\n- Works with welded, hinged, and constraint-connected parts\\n- Useful for calculating properties of entire assemblies\\n\\n**Example:**\\n```lua\\nlocal car = workspace.Vehicle.Chassis\\nlocal allParts = PhysicsUtil.GetConnectedParts(car)\\nprint(\\"Vehicle has\\", #allParts, \\"parts\\")\\n```","params":[{"name":"part","desc":"The part to get connections from","lua_type":"BasePart"}],"returns":[{"desc":"Array containing all connected parts plus the original part","lua_type":"{BasePart}"}],"function_type":"static","source":{"line":47,"path":"src/Mathf/PhysicsUtil.luau"}},{"name":"EstimateBuoyancyContribution","desc":"Estimates the total buoyancy force contributed by a collection of parts.\\n\\n**Usage Notes:**\\n- Only CanCollide parts contribute to buoyancy displacement\\n- Returns negative values if object would sink\\n- Positive values indicate floating capability\\n- Uses workspace gravity for calculations\\n- Assumes parts are fully submerged\\n\\n**Example:**\\n```lua\\nlocal boat = workspace.Boat\\nlocal parts = PhysicsUtil.GetConnectedParts(boat.Hull)\\nlocal buoyancy, mass, volume = PhysicsUtil.EstimateBuoyancyContribution(parts)\\n\\nif buoyancy > 0 then\\n\\tprint(\\"Boat will float!\\")\\nelse\\n\\tprint(\\"Boat will sink!\\")\\nend\\n```","params":[{"name":"parts","desc":"Array of parts to calculate buoyancy for","lua_type":"{BasePart}"}],"returns":[{"desc":"Total buoyancy force (positive = float, negative = sink)","lua_type":"number"},{"desc":"Total mass of all parts","lua_type":"number"},{"desc":"Total volume of collidable parts","lua_type":"number"}],"function_type":"static","source":{"line":81,"path":"src/Mathf/PhysicsUtil.luau"}},{"name":"GetCenterOfMass","desc":"Calculates the world-space center of mass for a collection of parts.\\n\\n**Usage Notes:**\\n- Returns weighted average position based on part masses\\n- Essential for realistic physics simulation\\n- Used as pivot point for rotational physics\\n- More accurate than using geometric center\\n- Works with any collection of parts\\n\\n**Example:**\\n```lua\\nlocal vehicle = workspace.Car\\nlocal parts = PhysicsUtil.GetConnectedParts(vehicle.Chassis)\\nlocal centerOfMass, totalMass = PhysicsUtil.GetCenterOfMass(parts)\\n\\n-- Visualize center of mass\\nlocal sphere = Instance.new(\\"Part\\")\\nsphere.Shape = Enum.PartType.Ball\\nsphere.Size = Vector3.new(1, 1, 1)\\nsphere.Position = centerOfMass\\nsphere.Anchored = true\\nsphere.Parent = workspace\\n```","params":[{"name":"parts","desc":"Array of parts to calculate center of mass for","lua_type":"{BasePart}"}],"returns":[{"desc":"World position of center of mass","lua_type":"Vector3"},{"desc":"Total mass of all parts","lua_type":"number"}],"function_type":"static","source":{"line":130,"path":"src/Mathf/PhysicsUtil.luau"}},{"name":"MomentOfInertia","desc":"Calculates the moment of inertia of a cuboid part around a given axis.\\n\\n**Usage Notes:**\\n- Moment of inertia represents resistance to rotational acceleration\\n- Higher values mean harder to rotate\\n- Takes into account both part shape and position relative to axis\\n- Uses parallel axis theorem for offset calculation\\n- Essential for realistic torque simulation\\n\\n**Example:**\\n```lua\\nlocal part = workspace.Wheel\\nlocal axis = Vector3.new(0, 1, 0) -- Rotation around Y axis\\nlocal origin = part.Position\\nlocal inertia = PhysicsUtil.MomentOfInertia(part, axis, origin)\\nprint(\\"Rotational inertia:\\", inertia)\\n```","params":[{"name":"part","desc":"The part to calculate inertia for","lua_type":"BasePart"},{"name":"axis","desc":"Axis of rotation (does not need to be unit vector)","lua_type":"Vector3"},{"name":"origin","desc":"Origin point of the rotation axis","lua_type":"Vector3"}],"returns":[{"desc":"Moment of inertia around the specified axis","lua_type":"number"}],"function_type":"static","source":{"line":166,"path":"src/Mathf/PhysicsUtil.luau"}},{"name":"BodyMomentOfInertia","desc":"Calculates the total moment of inertia for a connected body of parts.\\n\\n**Usage Notes:**\\n- Sums individual part inertias for entire assembly\\n- Axis should be the torque vector or (offset \xd7 force)\\n- Origin should be the center of mass of the assembly\\n- Used for calculating angular acceleration from torque\\n- Essential for multi-part physics simulation\\n\\n**Example:**\\n```lua\\nlocal robot = workspace.Robot\\nlocal parts = PhysicsUtil.GetConnectedParts(robot.Torso)\\nlocal com, mass = PhysicsUtil.GetCenterOfMass(parts)\\nlocal torque = Vector3.new(0, 100, 0) -- Spin torque\\nlocal inertia = PhysicsUtil.BodyMomentOfInertia(parts, torque, com)\\nlocal angularAccel = torque / inertia\\n```","params":[{"name":"parts","desc":"Array of connected parts","lua_type":"{BasePart}"},{"name":"axis","desc":"Rotation axis (typically torque vector)","lua_type":"Vector3"},{"name":"origin","desc":"Origin of rotation (typically center of mass)","lua_type":"Vector3"}],"returns":[{"desc":"Total moment of inertia for the entire body","lua_type":"number"}],"function_type":"static","source":{"line":203,"path":"src/Mathf/PhysicsUtil.luau"}},{"name":"ApplyForce","desc":"Applies a force to a Roblox physics body at a specific position.\\n\\n**Usage Notes:**\\n- Automatically calculates both linear and angular acceleration\\n- Uses Newton\'s laws and rotational dynamics\\n- Works on entire connected assembly, not just one part\\n- Force position determines torque magnitude and direction\\n- Modifies both Velocity and RotVelocity properties\\n- Setting velocity on one part affects entire connected body in Roblox\\n\\n**Physics Details:**\\n- Linear acceleration = Force / Mass\\n- Torque = Offset \xd7 Force\\n- Angular acceleration = Torque / Moment of Inertia\\n\\n**Example:**\\n```lua\\n-- Apply explosion force to a part\\nlocal part = workspace.Crate\\nlocal explosionPos = Vector3.new(0, 5, 0)\\nlocal force = (part.Position - explosionPos).Unit * 1000\\nPhysicsUtil.ApplyForce(part, force, part.Position)\\n\\n-- Apply force at edge of part for spin effect\\nlocal spinForce = Vector3.new(100, 0, 0)\\nlocal edgePos = part.Position + Vector3.new(0, part.Size.Y/2, 0)\\nPhysicsUtil.ApplyForce(part, spinForce, edgePos)\\n```","params":[{"name":"part","desc":"The part to apply force to (can be any part in assembly)","lua_type":"BasePart"},{"name":"force","desc":"Force vector to apply (in studs * mass / second\xb2)","lua_type":"Vector3"},{"name":"forcePosition","desc":"World position where force is applied (defaults to part.Position)","lua_type":"Vector3?"}],"returns":[],"function_type":"static","source":{"line":247,"path":"src/Mathf/PhysicsUtil.luau"}},{"name":"AcceleratePart","desc":"Accelerates a part using Newton\'s third law (action-reaction).\\n\\n**Usage Notes:**\\n- Applies equal and opposite forces to both parts\\n- Useful for projectile systems and explosions\\n- EmittingPart receives recoil force\\n- Conserves momentum in the system\\n- Force magnitude calculated from part mass and desired acceleration\\n\\n**Physics:**\\n- Force = Mass \xd7 Acceleration\\n- Action force on part, reaction force on emittingPart\\n- Both parts affected by their respective connected assemblies\\n\\n**Example:**\\n```lua\\n-- Cannon firing system\\nlocal cannon = workspace.Cannon.Barrel\\nlocal cannonball = workspace.Cannonball\\nlocal acceleration = Vector3.new(0, 0, -500) -- Fire forward\\n\\nPhysicsUtil.AcceleratePart(cannonball, cannon, acceleration)\\n-- Cannonball flies forward, cannon recoils backward\\n\\n-- Rocket propulsion\\nlocal rocket = workspace.Rocket\\nlocal exhaustPart = workspace.ExhaustParticle\\nlocal thrust = Vector3.new(0, 1000, 0) -- Upward thrust\\nPhysicsUtil.AcceleratePart(exhaustPart, rocket, -thrust)\\n```","params":[{"name":"part","desc":"The part to accelerate","lua_type":"BasePart"},{"name":"emittingPart","desc":"The part that emits/launches the other part (receives recoil)","lua_type":"BasePart"},{"name":"acceleration","desc":"Desired acceleration vector for the part","lua_type":"Vector3"}],"returns":[],"function_type":"static","source":{"line":300,"path":"src/Mathf/PhysicsUtil.luau"}}],"properties":[],"types":[],"name":"PhysicsUtil","desc":"","source":{"line":8,"path":"src/Mathf/PhysicsUtil.luau"}}')}}]);